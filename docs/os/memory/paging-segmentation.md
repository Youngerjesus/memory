## Paging 과 Segmentation 

***

Paging 과 Segmentation 기법들은 모두 가상 메모리를 관리하는 기법이다. 실제 메모리를 관리하는게 아니라 논리적인 가상의 메모리를 관리하는 기법

이게 나온 배경은 단편화 현상 떄문이다. 메모리에 프로세스가 적재되고 나가고 하면서 단편화 현상이 심해진다. (프로세스는 연속적인 메모리공간을 요구하기 때문에.)

그래서 일반적인 해결법은 메모리 압축이였는데 이는 별로 효율적이 아니라서 연속적인 메모리를 쓰는것처럼 보이는 가상 메모리 관리 기법인 Paging 과 Segmentation 이 나온것이다.  

가상 메모리는 커다란 메모리를 갖고 잇는 것처럼 사용할 수 있도록 하는 것이다. 

즉 내가 필요한 프로그램이 메모리가 5GB 가 필요한데 실제로는 여기서 다 쓰지도 않는다 일부만 조금씩 사용할 것 하지만 내 메모리는 4GB 라면 실행하는데 부족하다. 여기서 가상메모리를 사용하면 더 많은 메모리를 가진것처럼 할 수 있어서 이  프로그램을 올릴 수 있다. 

가상 메모리는 각 프로세스당 하나씩 배치가 되고 추가로 필요한 공간은 하드디스크나 SSD 를 이용한다. 프로세스의 일부만 메모리에 올리고 나머지는 보조기억장치에 둔다. 

각 프로세스당 가상 메모리를 배치하고 가상 메모리를 실제 메모리로 변환하는 걸 MMU(Memory Management Unit)가 페이지 테이블을 통해 하게 함으로써 CPU 는 프로세스 관리가 쉬워진다. 

(하나의 프로세스는 연속적인 메모리 사용을 원하고 있기 때문에 하지만 연속적인 값을 사용한다는 건 단편화 현상이 심해질 수 있다.)

### 페이징 

프로세스가 사용하는 주소 공간을 메모리 프레임 사이즈와 동일한 크기인 페이지로 잘라서 메모리에 저장하는 방식이다. (프로세스는 페이지로 잘리고 메모리는 프레임으로 잘린다.)

프로세스의 주소 공간을 일정한 크기로 잘랐기 떄문에 사이즈가 딱딱 안맞을 수 있다. 그래서 내부 단편화가 심하다는 특징이 있다. 


### 세그먼테이션 

프로세스를 논리적인 기준으로 서로 다른 크기의 세그먼트로 분한해서 메모리에 배치하는 방식을 말한다. 

각 세그먼트의 크기는 일정하지 않기 때문에 실제 메모리로 변환해주는 세그먼트 테이블에는 세그먼트 사이즈가 있다.

주로 자를 때 Code 영역 Data 영역 Stack 영역 이런식으로 자르는 경우도 있는데 각 상황마다 최적의 메모리 상황을 만들기 위해서 잘라야 하는 기준이 애매하다.

그래서 그냥 Paging 을 쓰는 경우가 많다. 

### 둘의 비교 

세그먼테이션과 페이징을 비교해보자면 세그먼테이션이 메모리를 보호하는 측면이나 공유하는 측면에서 더 낫다. 그치만 세그먼테이션 기법으로

일정한 기준으로 프로세스를 할당하다보면 크기가 다른 여러개의 흩어진 hole 들이 생기게 된다. 이 경우에 다음에 들어올 프로세스를 어떻게 배치하냐에 대한 최적화된 결정을 하기가 어렵고

메모리 외부 단편화 현상이 생기기 쉽다. 

### Demand Paging (요구 페이징)

프로세스가 메모리로 적재될 때 모든 페이지들을 다 쓰는게 아니다. 그래서 딱 필요한 만큼만 메모리에 올라가는 걸 요구 페이징이라고 한다.

가상 메모리는 대게 페이지로 관리되고 요구 페이징을 사용하는 가상 메모리는 페이지가 필요한 시점에 적재된다. 그러므로 필요하지 않은 페이지는 메모리에 올라가지 않는다. 

프로세스 내의 개별 페이지들은 페이저에 의해 관리된다. 페이저는 프로세스 실행에 필요한 페이지들만 메모리에 올리는 역할을 한다.

### 페이지 교체 

요구 페이징에서 나온대로 프로그램에 모든 페이지들을 메모리에 올려놓지 않고 필요한 페이지들만 올려놓는다. 

프로세스내에 어떤 동작에 필요한 페이지를 요청하는 과정에서 그게 메모리가 없다면 Page Fault(페이지 부재) 가 발생하게 되면 

원하는 페이지를 보조 기억장치에서 가지고 오게 된다. 하지만 이 상황에서 물리 메모리가 가득차있는 상황이라면 안쓰는 페이지들을 내리고

새로운 페이지를 올리는 교체가 이워저야 한다. 

#### 페이지 교체 기본적인 알고리즘

물리 메모리가 가득차있는 상황을 가정한다. 

1. 디스크에서 필요한 페이지들을 찾는다.

2. 페이지 교채 알고리즘(Clock Algorithm)에 따라 희생될 페이지를 선택한다. 

3. 희생될 페이지를 보조 기억 장치에 기록하고 새 페이지를 올린다. 

4. 그 다음 페이지 테이블을 수정한다. 

#### 페이지 교체 알고리즘

- FIFO 페이지 교체 알고리즘: 먼저 들어온 페이지가 먼저 나간다. 가장 기본적인 페이지 교체 알고리즘

  - 오래된 페이지가 나가는데 최적의 결정은 아니다. 라는 단점이 있다.
  
- LRU 페이지 교체 알고리즘: 가장 오랫동안 쓰지 않은 페이지를 교체한다.

- LFU 페이지 교체 알고리즘: 가장 사용한 횟수가 적은 페이지를 교체한다. 

- MFU 페이지 교체 알고리즘: LFU 와는 반대로 가장 참조 횟수가 많은 페이지를 교체한다. 참조 횟수가 적다는 건 최근에 올라왔으므로 사용될 가능성이 많다고 판단한 것이다.
 




  
    
 

 
# 폭주하는 카카오톡 트래픽에 대처하는 방법 

- 카카오톡 트래픽은 초당 62만건

- 메시지를 아직 읽지 않은 상대방한테 보내면 카카오톡 서버는 푸쉬를 보내게 되고, 메시지를 읽지 않은 유저의 폰은 미리 백그라운드로 로그인해놔서 메시지를 가져오게 된다. 이로 인해서 빠르게 읽기가 가능함.

- 서버의 Active Thread Count 를 기반으로 Busy Level 을 설정. 이를 기반으로 조치를 한다.
- 백그라운도 로그인 차단을 함.
  - Busy Level 1 일 때는 50% 차단
  - Busy Level 2 일 때는 100% 차단.
  - Busy Level 2 는 active Thread count / spawn thread count 가 40%~100% 일 때임.
- 그리고 읽지 않은 메시지 카운트를 동기화하는 요청도 딜레이 시킨다. (아직 필요가 없으므로.)
  - Busy Level 0 일 때는 60ms 주기로 요청 보냄.
  - Busy Level 1,2 일 때는 1800ms
- 재시도 횟수도 조절함
  - Busy Level 0,1 일 때는 2 retry
  - Busy Level 2 일 때는 0 retry
- Timeout 도 조절함
  - Busy Level 0 일 때는 5000ms
  - Busy Level 1,2 일 때는 500ms
- Async write 도 조절함
  - Busy Level 0,1 일 때는 FALSE
  - Busy Level 2 일 때는 TRUE
- 메시지 릴레이 딜레이도 조절함
  - Busy Level 0,1 일 때는 300ms
  - Busy Level 2 일 때는 100ms
- 챗로그 페이징도 조절함
  - Busy Level 0,1 일 때는 retry 2, fetch reduce 1/3
  - Busy Level 2 일 때는 retry 0


- 서버에서 특정 종류의 요청이 스레드를 점유하지 않도록. 그리고 특정 요청의 스레드가 임계점을 넘어서면 해당 요청은 실패하도록함.
  - 여기서는 프로토콜 별로 스레드를 분리했다.
  - 요청을 처리 못해서 장애로 벌어지기 보다는 에러를 빨리 내도록 하고 일정하게 처리할 수 있도록 하는 것.
  - 실제 처리량 자체도 올려야겠고, 장애가 나지 않도록도 해야한다. 여기서는 장애가 나지 않도록 하는 방법에 대해서 소개함. 

- 레디스는 초당 10만건의 요청을 넘겨버리면 급격하게 느려진다. 근데 실제로 이런 일이 일어났다고 하는듯.
  - 이를 해결하기 위해선 클러스터링을 적용해야지 
  - 그리고 특정 노드에 부하가 많다면 해당 노드에만 스케일 업을 하던지, 노드를 추가해서 부하를 줄이던지, 아니면 throttling 을 적용하던지 
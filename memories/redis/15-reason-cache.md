## 15 Reasons to Use Redis as an Application Cache

***

#### Summary 

캐시를 쓰는 이유 자체는 자주 사용하는 데이터를 캐시해서 어플리케이션의 응답 시간을 줄이기 위해서 사용한다.

- 매 요청마다 외부 데이터 소스에 접근하는게 아니라. 케시에 있는 데이터를 전달하는 방식으로


#### Cache 에 담을 데이터는 뭘까? 

- 설정 정보들(Configuration settings) 

  - 설정 정보를 disk storage 에 있는 텍스트 파일에서 데이터를 읽어오는 경우보다 캐시에서 읽어오는게 더 빠르다. 

-  현지화 및 국제화 데이터(Localization and internationalization data)

    - 유저 친화적인 어플리케이션은 국제화와 관련된 정보를 제공해주는데 이런 국제화 정보는 외부 저장소에 저장되는 경우가 많다.
    (관심사를 나누기 위해서 그러는 듯) 이런 정보를 캐싱해서 사용하면 응답 시간을 줄일 수 있다.

-  템플릿과 부분적인 렌더링 응답(Templates and partially rendered responses)

    -  동적으로 변하는 데이터들과 함께 미리 정의해둔 템플릿을 계속해서 이용한다면 템플릿을 매번 만드는 것보다 캐싱해놓고 사용하는게 더 낫다.   

- 재사용 가능한 결과들(Reusable results of compute-intensive functions)

  - 어플리케이션 리소스를 많이 사용해서 만들어 낸 결과를 재사용할 수 있다면 이를 캐시해놓는게 좋다. 
  
- 세션 데이터(Session Data)

  - 유저 데이터는 어플리케이션에서 주로 세션에 저장을 하는데 이를 캐시에 저장해두면 확장 가능한 어플리케이션이 될 수 있다.
  로드밸런서에서 요청을 라우팅 할 때 sticky session 을 사용하지 않아도 되니까 하나의 고정된 어플리케이션에서만 처리하는게 아니라 다른 어플리케이션에서 처리할 수 있으니까. 
  
- 데이터베이스 데이터(DBMS Data)

  - 데이터베이스에 실행하는데 비용이 비싼 쿼리들 같은 경우는 어플리케이션 레벨에서 캐싱해서 사용하기도 한다. 이를 통해서 성능을 높일 수 있어서. 
  
- API Response

  - 요즘 어플리케이션은 느슨한 연결(loosely coupled)로 연결되어 있다. 이런 경우 API 로 서로 응답하는 경우가 많은데 
  이런 경우에 API 응답 자체를 짧게라도 캐시에 넣어둬서 관리하면 서비스와 서비스간의 API 호출을 줄일 수 있고 성능을 향상 시키는게 가능하다. 
  
- Application Objects

  - 어플리케이션에서 재사용할 수 있는 객체나, 한번만 만들어 놓으면 되는 객체 같은 경우에는 캐싱을 해놓는게 성능이 좋다.
  예를 들면 유저 프로필 같은 걸 저장해두면 좋다.  
  대부분의 캐시는 객체를 직렬화 해서 저장하는 것도 가능하고 그냥 있는 그대로 저장하는 것도 가능할것이다. 

#### 캐시에 없는 항목은 뭘까? 

캐시에는 임시로 저장하는 데이터로 주로 재사용성이 있는 데이터를 저장하고 공유한다.

캐시에는 누락된 데이터가 있을 수도 있음을 알고 있자.

 
#### 어플리케이션 캐시 타입 

- __Private on-heap cache__ 

  - 애플리케이션에서 사용할 수 있는 가장 간단한 형태의 캐시로 프로세스와 캐시가 같은 메모리를 공유하는 걸 말하고 
  이 캐시에 접근할 수 있는 프로세스도 캐시를 소유하고 있는 프로세스로 딱 제한이된다. 
  같은 메모리를 사용하지만 메모리가 부족한 상황이 온다면 캐시에 있는 메모리를 우선적으로 제거해야한다. 캐시는 임시적인 메모리니까. 
  가장 빠르다는 장점이 있지만 두 가지의 단점이 있는데 캐시를 GC가 지우는 비용과 다시 필요할 때 캐시를 채우는 비용이 필요하다. 

  - 또 단점으로는 이 Private 한 캐시의 경우에는 확장에 열려 있지 않다. 인스턴스마다 캐시 공간을 넣어줘야한다. 이것만 해도 비용이 비싸고 이 경우 데이터 중복이
  발생할 확률도 높다.

- __Shared off-heap caches__

  - 이 방법은 애플리케이션 프로세스 외부에다가 캐시를 저장해놓고 사용하는 방법이다. 애플리케이션 프로세스 내부에다가 
  캐시하는 방법보다 속도차이는 좀 더 느리겠지만 이건 무시해도 될만한 수준이다. 그리고 여러 인스턴스 간의 캐시를 공유할 수 있으므로
  리소스 사용 측면에서도 좀 더 효율적이다. 
  
- __Distributed Shared Cache__

  - 이 방법은 원격에다가 캐시 클러스터를 유지하는 방법으로 데이터 중복을 이전 방법보다 더 줄일 수 있다.
  이렇게 하나의 캐시 클러스터만 어플리케이션이 바라보도록 하면 서로 독립적인 프로세스 처리가 가능해서 좋다. 


#### 분산된 공유 캐시로서의 Redis 

Redis 의 특징은 다음과 같다.

- __In-memory store__

  - 데이터는 모두 RAM 에 저장된다.
  
- __Optimized for speed__

  - ANSI C 로 작업되서 매오 효율적인 기계어로 컴파일된다. 그리고 싱글 스레드 이벤트 루프 구조를 사용해서 CPU 코어를 최적으로 사용한다. 

  - [싱글 스레드 이벤트 루프 모델](https://raghumb.gitbooks.io/a-guide-to-software-architecture/content/app_architecture_concepts/single_threaded_model.html)
  
    - 비교를 위해 먼저 멀티스레드 기반으로 요청을 처리하는 경우에서는 매 요청마다 스레드 풀에 있던 스레드가 요청을 처리한다. 
    이런 각각의 스레드는 Blocking I/O 를 동반한다. 그러므로 스레드가 모두 쓰이고 있다면 요청을 처리해줄 스레드는 없어진다.
    
    - 싱글 스레드 이벤트 루프 모델에서는 하나의 메인 스레드가 모든 요청을 다 처리한다. 하지만 각 요청마다 Blocking I/O 가 생길떄마다
    메인 스레드에서 새로운 스레드를 만들고 이 새로운 스레드가 Blocking I/O 를 처리하도록 한다. 그리고 다 처리한다음 메인 스레드에게 알려줘서
    요청을 마무리하도록 한다. 그러므로 CPU 코어를 효율적으로 쓴다. 
    
- __Support for arbitrary data__ 

  - Redis 에서는 바이너리 형태로 데이터를 저장하니까 어떠한 데이터든지 저장해서 사용하는게 가능하다. 
  
- __Key-Based access__

  - Redis 는 key-value 모델을 이용해서 데이터를 저장하고 가지고 온다. 그러므로 데이터 엑세스 효율이 좋다. 
  
- __Multi-key operations__

  - Redis 의 몇가지 명령은 여러 키에서 작동한다. 그러므로 O(N) 이 걸린다.
  
- __Atomicity of operation and transactions__ 

  - Redis 의 모든 작업은 Atomic 함을 보장한다. 그러므로 데이터의 일관성을 보장해준다. 

- __Data expiration__

  - Redis 의 Key 에는 TTL(Time to live) 라고 하는 데이터의 생존 시간을 넣어줄 수 있다. 
  TTL 이 설정된 키는 언제든지 시간을 다시 세팅하는게 가능하고 이 시간이 지나면 어떠한 요청 할 필요 없이 자동으로 데이터는 삭제된다.
  이를 통해서 레디스는 캐시 사이즈를 컨트롤 하는게 가능하고 일정 시간 지나면 캐시를 무효화하는게 가능해서 효율적인 사용이 가능하다.
  
- __Eviction polices__

  - 레디스는 메모리가 부족해질 경우 메모리 오류가 생기지 않도록 하기 위해서 키를 제거해서 메모리를 확보하는데
  이때 랜덤으로 데이터를 사라지게 할 수 있기도 하고 가장 최근에 사용한 키를 사라지게 할 수 있다. 이 방법이 추천되기도 한다.
  
- __Intelligent caching__ 

  - 레디스의 큰 장점 중 하나는 고급 자료구조를 이용해 지능형 캐시를 이용한다는 점인데 이는 단순히 SET GET 을 말하는게 아니라
  데이터를 효율적으로 조작한다는 의미다. 이 내용은 페이퍼에 담기에 너무 많아서 여기서 다루진 않겠다.
  
- __Distributed network server__

  - Redis 는 원격 서버로 연결되어 있고 경량형 TCP 를 사용한다.
  
- __Request pipelining__

  - 레디스는 매번 작은 패킷을 보내서 생기는 네트워크 비용을 줄이기 위해서 파이프라인 모드를 지원한다.
  이를 통해서 요청을 한번에 묶어서 보낼 수 있어서 네트워크 트래픽을 줄일 수 있다. 
  
- __High available__

  - Redis 는 Replication 을 이용한 고가용성을 보장해준다. 데이터 구조는 마스터-슬레이브로 이뤄져있다.
  캐시의 고가용성을 보장하기 위해서 모니터링과 페일오버를 위한 프로세스가 적용되기도 한다. 
  
- __Data persistence__

  - Redis 는 임시 저장소지만 필요한 경우라면 Disk 에 저장해놓는게 가능하다. 이 방법은 주로 장애가 났을 경우에
  복구할 때 사용하는데 이를 통해서 캐시가 없을 때 발생할 무수한 많은 로드들을 예방할 수 있다. 
  
- __Scalable shared-nothing clustering__

  - 레디스는 Scale out 이 가능하다 물론 메모리를 추가적으로 제공해줘야한다. 레디스의 확장은 샤드 형식으로 되는데
  자신이 담당하는 키 공간이 생긴다. 
  
- __Local cache replicas__

  - 레디스는 중앙에 캐시를 유지하면서 극단적이긴 하지만 어플리케이션 프로세스가 실행하고 있는 곳에도 배포하는게 가능하다. 
  이를 통해 replication 을 제공하는 것이 가능하다.

  
  
  
  

    
  

  

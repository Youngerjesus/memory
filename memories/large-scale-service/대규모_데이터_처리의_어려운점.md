# 대규모 데이터 처리의 어려운 점

대규모 데이터를 처리하는데 있어서 가장 큰 문제점은 메모리 위에서 모든 걸 다 처리할 수 없다는 점이다.

- 디스크는 메모리보다 10^5 ~ 10^6 배 느리다.
- 느린 이유는 버스의 전송 속도 차이도 있고
    - 메모리는 75GB/sec
    - 디스크는 58mb/sec
- 데이터 탐색에서 걸리는 차이다.
    - 메모리에서 저장된 데이터를 찾기 위해 포인터를 움직이는 속도는 10^-6 초 걸리지만
    - 디스크는 밀리초가 걸린다.
- 물론 OS 레벨에서 디스크의 성능을 높이기 위해서 여러가지 액션을 취한다.
    - 연속된 데이터를 몰아넣는다던지.
    - 한번에 가져올 때 Block 단위로 4KB 로 가져온다던지
    - Page Cache 를 이용한다던지.


### 단일 호스트의 부하 개선

- 요즘은 수평적 스케일링을 바탕으로 부하를 개선하지만 이것은 단일 어플리케이션의 성능을 어느정도 높여놓고 진행할 일이다.
- 단일 호스팅의 성능을 찾는 방법의 원칙은 하나있다.
    - 예측하지마라. 계측하라.
    - 즉 측정을 통해서 병목지점을 찾아내고 문제를 해결하라는 뜻이다.
- 측정은 어떻게 할까?
    - Load Average 를 확인해서 병목이 있는지 확인하자.
        - Load Average 는 `top` 이나 `uptime` 이라는 명령어를 통해서 확인할 수 있다.
        - Load Average 뜻은 얼마나 많은 프로세서가 Running or Uninterruptible waiting (I/O) 상태인지 나타내는 지표다.
        - 시스템 운영시 권장하는 에버리지는 0.7 이며 이것보다 높은 경우 신경을 써야한다.
        - CPU Core 당 1 을 나타내며 1 코어에 Load Average 값이 1 이라면 100% 로 처리하고 있다는 뜻이다.
    - 병목이 있다면 CPU 와 I/O 중 병목 상태를 확인해보자.
        - `vmstat` 으로 CPU 와 I/O 의 비율을 확인해보고 각 병목에 대해서 처리하자.
    - CPU 가 병목인 경우.
        - 먼저 사용자 프로그램이 병목인지 시스템 프로그램이 병목인지 확인하자. 이는 `top` 이나 `sar` 명령어로 확인하는게 가능하다.
        - 또한 `ps` 명령어로 어떤 프로세스가 CPU 를 얼마나 쓰고 있는지 확인해보자.
        - 프로세스를 찾은 후 상세하게 분석하고 싶다면 `strace` 로 찾거나 `oprofile` 로 병목 지점을 좁혀보자.
            - strace 로 프로세스가 호출한 시스템 콜을 추적하는게 가능하다.
            - oprfoile 로 어떤 함수가 CPU 자원을 많이 사용하는지 추적하는게 가능하다.
    - I/O 가 병목인 경우
        - I/O 가 병목인 경우는 입출력이 많아서 병목이거나, 스왑영역을 사용해서 병목이거나 대부분 둘 중 하나다.
        - `sra` 나 `vmstat` 으로 스왑을 사용하는지 보자.
        - 스왑이 발생하고 있다면 특정 프로세스가 메모리를 독차지 하고 있는건 아닌지 `ps` 명령어로 확인해보자.
        - 그리고 프로그램의 오류로 지나친 메모리를 사용하고 있을수도 있다.
        - 입출력이 빈번하게 발생하고 있다면 캐시서버를 놓는 것을 통해서 해결하거나, 알고리즘 개선으로 입출력을 줄이거나 메모리를 증설하는 걸로 막자.
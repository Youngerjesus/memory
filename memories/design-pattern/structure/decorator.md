# Decorator

***

기존에 있는 코드를 변경하지 않으면서 기능을 추가할 수 있는 패턴.

- 특징으로는 부가 기능을 런타임 시점에 다이나믹하게 추가할 수 있다는 것.
- 부거적인 기능은 일반적으로 상속을 통해서 해결할려고 하는게 기본적이다. 하지만 상속은 유연하지는 않다. 클라이언트의 요구사항이 런타임 시점에 다양하게 요구할 수 있는 경우에는 Decorator 패턴을 이용해보는 것도 좋다.
- 상속의 한계를 느낄 때, 여러 서브 클래스의 기능을 더한 클래스가 필요할 때 데코레이터 패턴을 이용하면 좋겠다.이렇게 하면 새로운 클래스를 만들지 않아도 될 수도 있다. 기존의 클래스를 조합하는 식으로 사용이 가능하기 떄문에.

### 장점

- 새로운 클래스를 만들지 않고 기존의 클래스를 조립하는 식으로 기능을 추가할 수 있다.
    - SRP 를 지킬 수 있다.
- 컴파일 타임이 아닌 런타임 시점에 동적으로 기능을 부여하는게 가능하다.
    - 데코레이터 패턴을 사용하지 않는 경우 기능을 부여할 때 모든 경우의 수를 생각해서 해당 기능을 가진 클래스를 줘야한다.
    - 하지만 데코레이터 패턴은 데코레이팅 할 지 여부만 판단하면 되므로 상대적으로 더 간단하다.

### 단점

- 동적으로 기능을 부연하는 코드가 추가된다는 점이 있다.

### 실제로 사용하는 예

```java

```

- Adapter 예와 같다. 보는 목적에 따라서 데코레이터 패턴으로 볼 수도 있고 어댑터 패턴으로 볼 수도 있다.
- 점점 더 기능을 추가하는 것.

```java
Collections.synchronizedList(list)

Collections.checkedList(list, 구체적인 클래스 타입);

Collections.unmodifiableList(list)
```

- 컬렉션에 있는 여러가지 메소드들은 기존의 리스트에 여러 부가적인 기능을 제공해주는 데코레이터 패턴이 적용된 예이다.

또 이외에 HttpServletRequestWrapper 가 있다. 기본적인 HttpServlerRequest 에다가 부가적인 기능을 추가하고 싶다면 이 Wrapper 를 상속한 다른 부가기능을 제공해주는 Wrapper 를 만들고 이를 사용하면 된다.

마지막으로 스프링 웹플럭스에서 지원하는 ServerHttpRequestDecorator, ServerHttpResponseDecorator 가 있다.이것도 HttpServlerRequestWrapper 와 비슷하다.
# Chain of responsibility

행동과 관련된 디자인 패턴

이름만 보면 책임들의 체인을 떠올리면 된다.

- 여기서 책임은 SOLID 의 SRP 를 떠오르면 된다. 클래스가 특정한 책임을 가지고 있다. 그리고 이것들이 연결된 구조.
- 요청을 처리하는 쪽과 요청을 보내는 쪽을 구별시키고 (인터페이스 타입에 의존하도록 하면서) 하나의 클래스가 너무 많은 책잉을 가지고 요청을 처리할 때, 책임마다 클래스를 분리시켜서 처리하도록 만드는 패턴이다.

### 대안

- 하나의 클래스에 책임이 너무 많은 구조
- 상속을 통해서 자신이 처리해야 할 일만 하고 부모에게 넘기는 구조로 풀 수도 있다. 대신에 이 문제점은 클라이언트의 코드가 변경될 수 있다. 어떠한 구현체를 쓸 지.
    - 상속의 문제점이 또 나올 수 있다. 상속은 한 부모만 가지므로 한 방향으로만 확장이 가능하다 여러 부모의 스펙을 만족하는 방향으로 확장할 수 없다.
- Chain of responsibility 패턴을 사용하면 클라이언트는 요청을 처리하는 쪽의 구현체에 대해서 몰라도 된다. 그냥 요청을 넘기면 된다.  요청을 처리하는 쪽은 SRP 에 따라서 각 책임마다 자신이 처리하는 일이 나눠져있다.

책임을 만등어주는 역할을 어디선가 해야한다. 객체를 생성해주는 그 관심사는 App 이 시작할 때 해줘야겠지.

### 장점

- 클라이언트의 코드가 변경하지 않고 요청을 처리하는 코드를 확장하는게 가능하다.

### 단점

- 디버깅이 쉽지 않다.
- 체인의 순서가 중요한 경우가 있다. 이를 고려해야할 수도 있다.

### 실제로 사용하는 예

```java
Filter filter = new Filter() {
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException {
		chain.doFilter(request, response, chain);
	}
}
```

- Java 에서 ServletFilter 가 Chain of responsibility 패턴을 이용한 경우다.  서블릿 필터는 각 필터마다 자신의 책임을 가지고 요청을 처리한 후 다음 필터에게 넘긴다.
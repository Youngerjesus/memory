## Git Merge 전략 

#### Create a merge commit (Merge Commit)

> 보통 일반적인 merge 전략이다. 

Merge 하기 전 브랜치의 커밋이 모두 남아있고 어떻게 merge 되었는지 한번에 볼 수 있다.

다만 브랜치가 많아지거나 머지 횟수가 많아지면 가독성이 떨어진다.  
 

#### Squash and Merge

> 여러 개의 commit 을 하나로 합친 후 merge 하는 전략이다.

merge 명령중에 --squash 옵션을 주면 이 방법으로 merge 를 한다.

이 방법은 merge 할 commit 을 모두 하나의 commit 으로 합친 후 타겟 브런치에 병합하는 전략이다. 

이 방법의 장점은 merge commit 이 남아 있어서 merge 된 브랜치가 있었다는 것을 히스토리에서 볼 수 있고 자잘한 commit 들이 없어서 
가독성을 떨어뜨리는 일은 없다라는 점이다.

단점은 merge 된 commit 이 하나로 되어있기 떄문에 어떠한 과정으로 변경되었는지 알 수는 없다는 점이다.

#### Rebase and Merge

> Rebase 기능을 이용해서 merge 하는 전략이다.

Rebase 는 말 그대로 브랜치의 히스토리들의 베이스를 변경하는 걸 말하는데 a 브랜치의 변경 사항이 마치 b 브랜치에서 변경된 것 처럼 바꿀 수 있다는 것이다.
즉 머지하면 b 브런치에 커밋이 된다. 

Rebase 는 머지된 브랜치의 커밋을 모두 살려놓기 때문에 어떤 부분을 수정헀다는 정보는 전부 알 수 있지만 해당 브런치가 언제 머지 되었는지는 알 수 없다. 
즉 merge 커밋이 생기지 않는다. 

그래서 Rebase 를 이용한다면 태그에 좀 더 신경써야한다.

이 전략을 사용한 후 브런치를 삭제하면 아주 꺠끗한 브런치 그래프를 얻을 수 있다.   


#### 비교 Rebase vs Squash

둘 다 merge 한 후 브랜치를 삭제한다고 가정해보자. 

Rebase 는 커밋 내용이 남아있지만 merge 했다는 내용이 없다. 

Squash 는 merge 했다는 내용이 남아있지만 커밋 내용이 없다. 그냥 `Merge pull request #...` 이런 내용만 있겠지 

그래서 Rebase 를 선호하는거 같다. 

협업을 할 때 Rebase 방식만 하고 커밋의 개수를 딱 한개만 하도록 하고 적절한 태그를 달아주기만 하면 충분한 설명이 되지 않을까

   
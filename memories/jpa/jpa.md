## JPA 

#### 패러다임의 불일치란? 

JPA 를 사용하는 이유가 패러다임의 불일치를 해결할 수 있어서이다.

이 패러다임의 불일치는 어플리케이션을 개발할 땐 Java 라는 객체 지향 프로그래밍을 쓰면서 추상화, 캡슐화, 상속, 다형성
등을 사용하지만 객체를 저장할 때 이 관계형 데이터베이스의 개념인 데이터중심의 집합적인 개념에 맞춰서 저장을 해야한다.
이와 같은 개념적인 불일치가 패러다임의 불일치라고 하고 JPA 는 중간에서 이를 해결해주는 역할을 요구한다. 

JPA 가 해결해주는 문제는 다음과 같다.

- 상속 

  - 객체 지향에서는 상속이 있지만 관계형 DB 에서는 상속이 없다. 하지만 이와 유사하게 테이블에 슈퍼타입과 서브타입이 존재한다.
  슈퍼타입과 서브타입 방식중에 조인응 이용한 방식을 사용하기 위해서는 데이터베이스에 저장할때 두개의 Insert 쿼리가 나가야하고
  조회할 땐 조인을 사용해야한다. 이와 같은 작업을 JPA 에서 서브 타입을 저장할 때 조회할 때 알아서 해줌으로써 상속의 패러다임을
  해결해준다. 

- 연관관계 

  - 객체는 참조를 통해서 다른 객체와 연관관계를 맺지만 테이블은 FK 를 통해서 다른 테이블과 연관관계를 맺는다.
  객체를 테이블에 맞춰서 FK 를 가지도록 사용하면 되지 않겠냐라고 물을 수 있지만 이는 객체지향적인 방법이 아니다.
  그러므로 객체는 객체지향처럼 사용하고 테이블은 테이블 처럼 사용하고 중간에서 이를 변환해주는 작업이 필요한데 이를 JPA 가 지원해준다.
  JPA 에서 Member 가 있고 Member 는 Team 을 참조한다 Member 를 테이블에 저장한다고 하면 Team 의 저장은 Member 에서 Team 을 참조해서 아이디 값만 저장하도록 변환해야하고
  Member 를 테이블에서 조회한다고 하면 Member 테이블에 가진 Team 의 FK 를 바탕으로 Team 에 있는 데이터도 다 가지고와서
  Team 이라는 객체를 만들어주고 Member 객체가 참조하도록 해줘야한다. 이와 같은 연관관계를 맺는 작업이 서로 다른데 JPA 에서는 이를 지원해준다.
  
- 객체 그래프 탐색

  - 객체 지향에서 객체는 참조를 통해 타고타고 들어가서 다른 객체를 참조하는게 가능하다. 
  하지만 테이블에서는 처음 실행한 SQL 문을 기준으로 어디까지 조인을 했는지에 따라서 참조가 제한된다. 그러므로 이처럼 객체를 탐색할때도
  서로가 조금씩 다르다. JPA 에서는 이를 지연로딩과 프록시 객체를 이용해서 연관된 객체를 실제로 사용할 때 그때 SELECT 쿼리가
  나가도록 해서 객체지향처럼 참조가 가능하도록 한다.  

#### JPA 를 사용하는 이유는? 

- 생산성 

  - 단순한 CRUD 작업의 경우에 SQL 문을 작성하지 않아도 된다. 조회할 객체가 있다면 Id 값만 던져주면 SELECT 문이 알아서
  나가고 데이터를 저장할때도 객체를 JPA 에 저장하는 메소드만 호출하면 알아서 INSERT 쿼리가 나간다.
  
- 유자보수 

  - SQL 의존적인 작업을 안해도 된다라는 것. SQL 위주의 작업의 문제점은 변경 포인트가 많아진다는 점인데. SELECT 문 기준으로
  칼럼이 하나만 추가되도 모든 SELECT 문을 다 바꿔줘야 한다. 

- 패러다임의 불일치 문제를 해결해준다. 

- 성능 

  - JPA 는 애플리케이션과 데이터베이스 사이에 위치해서 Dirty Checking, 트랜잭션 Write Behind, 1차 캐싱과 같은
  기능을 제공해줘서 성능 이점을 제공해준다. 
  
#### EntityManger

엔터티를 영속성 컨택스트에 저장하고 삭제하는 등의 관리해주는 역할을 하는 걸 엔터티 메니저라고 한다.  

#### 엔터티의 생명주기는?

엔터티에는 4가지 상태가 존재한다.

- Transient: 처음 객체가 만들어진 상태로 영속성 컨택스트와 관련이 없는 상태

- Managed: 영속성 컨택스트에 저장된 상태

  - 영속성 컨택스트가 엔터티를 관리해주면 다음과 같은 장점이 있다.
  
    - 1차 캐시
    
      - REPEATABLE READ 수준의 격리를 제공해준다. 
    
    - 동일성 보장
    
    - 트랜잭선 Write Behind - INSERT 쿼리를 모아놨다가 트랜잭션 커밋전에 플러쉬 해주는 걸 말한다. 
    
    - Dirty Checking - 1차 캐쉬에 엔터티의 스냅샷을 보관해놓고 플러쉬할 때 엔터티와 스냅샷을 비교하면서
    변경사항이 있는지 체킹하고 있다면 Update 쿼리를 내보내는 걸 말한다. 
    
    - 지연 로딩
    
      - 프록시 객체를 앞에두고 영속성 컨택스트를 통해서 실제 객체를 사용할때 SELECT 쿼리를 내보내는 방법으로
      Detached 상태에선 사용하지 못한다.   

- Detached: 영속성 컨택스트에 저장되어 있다가 분리된 상태

  - Detached 상태로 만드는 방법은 3가지가 있다. 
    
    - em.detach(): 의도적으로 detached 상태로 만드는 방법
    
    - em.clear(): 영속성 컨택스트를 초기화 하는 방법
    
    - em.close(): 영속성 컨택스트를 초기화 하는 방법
    
  - Detached 상태에서 Managed 상태로 만드는 방법으로는 em.merge() 메소드가 있다. 

- Removed: 영속성 컨택스트와 데이터베이스에서 삭제된 상태 

  - 바로 삭제되지 않고 쿼리를 모아두는 저장소에 삭제 쿼리를 넣어놓고 영속성 컨택스트에서 지운다. 

#### 동일성과 동등성 비교

동일성은 == 로 참조값 비교를 말하고 동등성은 실제 인스턴스는 다르지만 가지고 있는 값이 같은지 비교를 하는 걸 맗나다.


#### 기본 키 매핑

객체를 데이터베이스에 저장할 때 기본 키를 직접 할당하고 이를 DB 에 반영하는 방법이 있고

데이터베이스가 생성해주는 기본 키 값을 받아서 Id 를 할당하는 방법이 있다. 이는 총 3가지 방법이 있고 데이터베이스 벤더마다 
조금씩 다르다. 그러므로 @GeneratedValue 의 기본 전략은 AUTO 로 데이터베이스 벤더에 맞춰서 기본 키 생성을 해준다. 

- Identity: MySQL 에서 사용하는 방식으로 기본 키 생성을 데이터베이스가 해주는 방식이다.

  - MySQL 의 AUTO_INCREMENT 방식으로 데이터베이스에 Id 값을 하나씩 채우는 방식으로 사용한다. 
  그러므로 이 방식으로 사용하면 객체를 DB 에 저장할때 트랜잭션 Write Behind 로 한번에 모아서 보내는데
  그러지 않고 persist() 메소드를 만나면 그때 INSERT 쿼리를 날리고 Id 값을 받아온 다음에 영속성 컨택스트에 저장하는
  작업을 한다. )JDBC3 에 들어온 기능으로 Statement.getGeneratedKeys() 를 통해서 데이터를 저장하면서 추가로 기본 키
  값을 조회하는 기능을 이용한다.)

- Sequence: 오라클에서 주로 사용하는 방식으로 데이터베이스에 시퀀스라는 오브젝트를 통해서 기본 키를 생성하는 방법을 말한다.
    
  - 시퀀스 전략은 데이터베이스에서 시퀀스를 받아와서 메모리에 저장해놓고 그 Sequence 를 모두 사용하면 다시 데이터베이스에
  요청해서 다음 시퀀스를 받는 형식으로 이뤄진다. IDENTITY 와 비교하자면 IDENTITY 는 트랜잭션 Write Behind 를
  지원하지 않지만 여기서는 지원한다. 
  
- Table: 기본 키 생성해주는 테이블을 이용한다.
 
   - 테이블 전략은 기본 키 생성을 해주는 테이블을 만들어놓고 INSERT 하기 전에 이 테이블에서 다음 기본 키 값을
   읽어오고 기본 키 생성 테이블을 UPDATE 해주는 방식을 이용한다. 

  
#### 필드와 칼럼 매핑

@Column

- 이 에노테이션을 원시 타입에 사용할 때는 기본 값이 nullable=true 이므로 원시타입은 NULL 이 될수 없기 때문에
 nullable=false 로 설정해놔야 한다.  
 
@Transient

- 특정 필드를 데이터베이스에 매핑하지 않는 걸 말한다. 

@Enumerated

- EnumType.ORIGINAL 과 EnumType.STRING 이렇게 있는데 ORIGINAL 은 순서를 저장하는 거고 기본 전략이다.
EnumType.STRING 은 문자 그대로 저장하는 걸 말하며 ORIGINAL 보다 사이즈는 더 많이 저장하지만 ORIGINAL 보다 
좀 더 유연하다. ORIGINAL 은 중간에 끼어들기가 어려우므로 

#### 연관관계의 주인이란

객체를 양방향 관계로 JPA 에서 만들도록 하면 키의 주인을 누구로 할 것인지를 결정하는 걸 말한다. 

참조는 두방향에서 모두 가능한데(멤버 -> 팀, 팀 -> 멤버) 키는 하나만 있으면 되므로 누가 키를 관리할 거신지 말한다. 

JPA 에서 키를 가지고 있는 쪽이 수정 권한이 있고 주인이 아닌 쪽은 읽을 수만 있다. 

그러므로 주의해야하는데 주인이 아닌쪽에서 등록을 할려고 하면 테이블에 값이 안써지기 떄문에 양방향 관계를 할 땐 
키의 주인이 아닌쪽에서 등록을 할 경우에 키의 주인에서 등록을 해줘야한다.  

그리고 키의 주인에서 연관관계를 변경하는 경우에는 기존의 연관관계가 남아있으면 안되므로 지워주는 역할까지 해줘야한다. 

#### 상속 관계 매핑

@MappedSuperClass

- 여러 엔터티에서 공통적으로 사용하는 칼럼이 있을때 사용하는 방법이다. 주로 모든 엔터티에서 레코드가 만들어진 시간과 마지막으로 업데이트 한 시간
같은 칼럼을 넣을 때 이 방식을 사용한다.

@Inheritance(strategy = InheritanceType.JOINED) 

- 부모의 기본키를 자식이 받아서 자식의 기본키 겸 부모를 참조하는 외래 키 겸 사용하는 방식을 말한다.

- 그러므로 자식 테이블의 데이터를 조회할 땐 항상 부모 테이블과의 조인이 일어난다. 그리고 자식 테이블에 값을 넣기 위해선
부모 테이블에서 INSERT 쿼리가 나가야한다.

@Inheritance(strategy = InheritanceType.SINGLE_TABLE)

- 하나의 테이블에 여러 자식의 칼럼이 모두 들어가는 경우를 말하며 안쓰느 칼럼은 모두 NULL 로 넣는 구조다. 

- 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.

@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)

- 자식 테이블마다 각각의 테이블을 두는 방식으로 자식 테이블을 구별하는 서브 타입이 부모 클래스에 없어도 된다는 
장점이 있지만 여러 자식 테이블을 통합해서 조회할 때 성능이 느리다는 단점이 있다.

#### 영속성 전이:CASCADE

특정 엔터티를 영속 상태로 바꿀 때 연관된 엔터티도 함께 영속 상태로 바꾸고 싶을 때 CASCADE PERSIST 를 사용한다. 

특정 엔터티를 지울 때 연관된 엔터티도 함께 지워져아 한다면 Cascade REMOVE 를 사용한다. 

#### 고아 객체

부모 엔터티와 연관관계가 끊어진 엔터티를 고아 객체라고 한다. 

ORPHAN REMOVAL 를 통해서 부모 엔터티와 참조가 끊어진 고아 객체를 자동적으로 삭제하도록 설정할 수 있다.

고아 객체를 사용할 땐 참조가 딱 한군데만 바라볼 때 사용하도록 하는게 중요하다. 다른 곳에서도 참조하고 있다면 문제가 발생할 수 있다.

#### 값 타입과 엔터티의 차이점

값 타입은 엔터티의 라이프사이클에 모두 의존한다 라는 점. PK 값이 없다라는 점이 있다.

#### 값 타입을 다룰 때 조심해야 할 점 

값 타입의 객체를 사용할 땐 객체의 참조를 공유해서 사용하지 않도록 조심해야한다. 객체의 참조를 공유함으로써 원하지 않았던 변경이 일어날 수도 있기 때문이다.
이를 위해서는 객체의 값을 바꾸는 방식보다 객체를 생성해서 사용하도록 권장해야하는데 이를 위해서 IMMUTABLE 하도록 SETTER 가 있도록 함녀 안된다. 

#### 값 타입 컬렉션과 OneToMany 의 차이점 

값 타입 컬렉션은 테이블에서 관리하지만 식별자가 없다. 그러므로 해당 로우만 찾아서 변경하기가 힘들다. 
이런 점 때문에 값 타입 컬렉션에서 변경이 일어나면 모두 지우고 다시 넣어주는 일을 한다. 그래서 좀 문제가 있다.  
그러므로 변경이 자주 발생할 거 같으면 OneToMany 관계에 Cascade 와 Orphan Removal 옵션을 줘서 
엔터티와 라이프사이클을 같도록 만드는게 더 낫다. 

#### @Converter

컨버터를 사용하면 엔터티의 데이터를 변환해서 데이터베이스에 저장하는게 가능해진다. 
예를들면 Boolean 타입인 경우 데이터베이스에 1 이나 0 값으로 들어가는데 Y 나 N 값으로 들어가도록 바꾸는게 가능하다. 

#### @EntityListener 

모든 엔터티의 라이프사이클애 관련된 이벤트 메소드가 있다. 주로 엔터티의 로그를 남기고 싶은 경우에 사용한다. 

- PrePersist

  - 엔터티를 영속성 컨텍스트에 저장하기 전에 호출되는 메소드다.  
  
- PreRemove

  - remove() 를 통해서 엔터티를 지우기전에 호출되는 메소드다.

- PreUpdate

  - commit() 을 통해서 엔터티를 데이터베이스에 저장하기 전에 호출되는 메소드다. 
  
- PostUpdate

  - commit() 을 통해서 엔터티를 데이터베이스에 저장한 직후 호출되는 메소드.  

- PostLoaded

  - 엔터티가 영속성 컨택스트에서 조회된 직후 또는 2차 캐시에서 조회된 직후에 사용되는 메소드다. 
  
#### 엔터티 그래프

엔터티를 조회할 때 연관된 엔터티를 함께 조회하기 위한 기능들로 주로 반복되는 패치조인을 줄이기 위해서
엔터티 그래프를 사용하기도 한다. 

#### Optimistic Lock

Optimistic Lock 은 트랜잭션이 충돌하지 않을 것이라는 가정하에 방법으로 레코드에 버전이라는 칼럼이 있고
이를 트랜잭션 커밋전에 버전이 내가 알고있는 버전이 맞는지 버전이 업데이트 되지 않았는지 확인하는 방법으로 격리를 추가적으로
제공하는 방법이다. 

주로 Optimistic Lock 을 사용하는 경우에는 Lost Update 상황속에서 마지막 커밋을 인정하는 경우가아니라
최초의 커밋만 인정을 해야하는 경우에 사용하기도 하고 격리 수준을 너무 높이지 않지만 동시성 문제를 해결하고 싶은 경우에
쓰인다.  
 


#### JPA 성능 최적화 

##### NULL 제약 조건과 JPA 조인 전략 

JPA 에서 @JoinColumn 을 통한 테이블 조인을 할 경우에 NULL 여부에 따라서 기본적으로 수행할 조인이 다르다.
NULLABLE = true 인 경우에는 Left Outer Join 을 하지만 NULLABLE = false 인 경우에는 INNER JOIN 을 한다. 
INNER JOIN 만으로 해결되는 경우에 Left Outer Join 으로 해결하는 경우라면 더 많은 데이터를 가지고오게 되니까 성능적으로 더 안좋다. 

#### 패치조인 

#### 트랜잭션 쓰기 지연 

#### 1차 캐시 
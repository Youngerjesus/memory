# CQRS (Command Query Responsibility Segregation)

https://martinfowler.com/bliki/CQRS.html

https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf

***

먼저 용어 정리부터 하자. 

- Command: 명령으로 시스템의 데이터를 변경하는 걸 말한다. 

- Query: 조회로 시스템의 데이터를 조회하는 걸 말한다. 

- Responsibility: 책임으로 시스템의 구성요소의 역할을 말한다. 작은 건 클래스 부터 패키지까지 큰 것은 웹서버나 DB 가 될 것이다.  

- Segregation: 분리로 역할에 따라서 구성 요소를 나눈다는 말이다. 

즉 이런 용어를 바탕을 정리하자면 명령 역할을 수행하는 구성 요소와 쿼리 역할을 수행하는 구성 요소를 나누는 것이 CQRS 이다. 

### 왜 명령과 조회를 분리할까? 

같은 도메인을 사용해서 명령과 조회를 같이 하면 되지 않을까? 쉽게 설계도 되고 괜찮다고 생각할 수 있다. 

그리고 CQRS 를 위해서 같은 코드를 중복하는 경우가 많아져서 개발이 느려지는 단점도 있을 것 같다고 생각할 수 있다.

하지만 이런 단일 도메인을 사용하면 문제가 있다. 

- 명령과 조회는 각각이 원하는 요구 사항이 다를 수 있다. 즉 필요한 역할이 다를 수 있다. 명령에서는 어떠한 속성이 필요하지만 조회를 하는데는 전혀 필요하지 않은 속성이 있을 수 있다. 
이 때문에 조회를 하는데 필요없는 데이터까지 조회를 하는 경우도 생긴다. 조회 같은 경우는 원하는 요구사항중에 많은 트래픽을 견딜 수 있도록 처리량이 높아야 한다. 
하지만 명령의 요구사항 때문에 조회가 느려지기도 하고 명령이 lock 을 이용한다면 조회를 방해하기도 한다.  

    - 명령 같은 경우는 하나의 도메인을 수정 하는 경우가 많지만 조회는 여러 모델을 걸쳐서 사용하기도 한다. 
    
    - 조회 같은 경우는 성능을 원하는 요구사항이 많다. 명령이 이를 방해하면 안되고 조회는 이를 어떻게 효과적으로 할 지를 생각해야한다. 
    그러다보면 단일 모델의 경우에는 성능 향상의 한계가 있다. 
    
    - 둘 다 성능 향상의 목적으로는 명령 쪽으로는 비동기 방식으로 모아서 처리할 수 있고 조회쪽에서는 캐시를 이용하는 방법도 있다.

### CQRS 는 어떻게 구현할까? 

CQRS 구현에는 한 프로세스 내에서 사용하는지 프로세스를 나누는지, DB 를 같은 걸 쓰는지 다른 걸 쓰는지에 따라서 나뉜다.

#### 같은 프로세스와 같은 DB 를 사용하는 경우 

코드 수준에서만 명령과 쿼리가 구분되고 데이터를 구분하지는 않는 것이다. 

조회할 때 필요한 데이터만 뽑아오는 방식으로 사용되는 것 같다. Response DTO 를 이용하는 것 같다. (검증 필요)

#### 같은 프로세스와 같은 DB 그러나 다른 테이블을 사용하는 경우 

이 방법은 쿼리 전용 테이블을 따로 만드는 경우다. 

명령에서 쿼리 전용 테이블에 INSERT 와 Update 를 해준다. 

#### 같은 프로세스를 사용하되 다른 DB 를 사용하는 경우 

이 방법은 명령과 쿼리의 DB 를 분리해서 사용하는 방식으로 명령이 데이터를 변경하면 쿼리 쪽 DB 에 변경을 전파해야한다. 

이 변경 전파 방법이 중요하다.

#### 다른 프로세스를 사용하되 다른 DB 를 사용하는 경우. 

주로 마이크로서비스에서 이용하는 방식이다. 이 방법도 변경의 전파 방법이 중요하다. 


### 변경 전파는 어떻게 할까?

변경 전파에서 중요한 건 데이터를 유실하지 않는지, 즉시 동기적으로 처리되어야 하는지, 중복이 전달되는 경우 어떻게 처리할 것인지?
중복이 허용되는지? 

크게 3가지 방법을 알아보자 

- 카프카와 같은 메시지 서비스를 이용해서 명령 DB 의 변경 내용을 쿼리 DB 로 메시지를 보내는 것

  - 구현이 쉽다는 장점이 있지만 따져줘야 할 중요한 것들이 있다.  
  
  - 메시지를 유실하지 않을 것
  
  - 즉시 동기가 필요한지 유무
  
  - 메시지가 중복 처리되지 않도록 하는 것 카프카 뿐 아니라 쿼리 쪽 DB 에서도 이를 처리하도록
  
    - 쿼리 쪽 DB 에 메시지를 처리한 순서를 저장해두는 것. 
  
  - 장애가 나서 메시지가 처리되지 않았다면 이를 어떻게 처리할 것인가?   

- 변경 내역을 기록하고 별도의 전파기를 이용해서 전달하는 것 

  - 변경 내역은 별도의 테이블에 기록하도록 하고 전파기에서 이를 읽어서 쿼리 DB 로 전파하도록 해야한다. 
  
  - 변경 내역이 테이블에 기록한다는 것 자체가 트랜잭션의 성질을 부여한다는장점이 있다. 
  
  - 별도의 메시징 서비스를 같이 쓰는 방법도 있다. 
  
- DB 가 제공하는 CDC 기능을 이용하는 것이다. 

  - 예를 들면 DB 의 변경 내역인 바이너리 로그를 읽어와서 이를 쿼리쪽 DB 에 적용하는 걸 말한다. 
  
  - 두번째 방식과 유사하지만 별도의 테이블에 기록하지 않아도 된다는 특징이 있다. 
  
  - 이 방법도 별도의 메시징 서비스를 같이 쓰는 방법도 있다. 
